-- 'CREATE TABLE' DDL을 통해 특정 테이블을 생성할 수 있다.
-- '()'사이에 컬럼을 쓰고, 마지막은 세미콜론으로 끝난다.
CREATE TABLE EMP 
( 
empno number(10) primary key, 
ename varchar2(20), 
sal number(6) 
);





-- 제약조건으로 PRIMARY KEY를 설정(해당 방법이 정석이다.)
-- "CONSTRAINT 제약조건명 PRIMARY KEY(기본키 칼럼명)"
CREATE TABLE EMP
(
empno number(10),
ename varchar2(20),
sal number(10,2) default 0,
deptno varchar2(4) not null,
createdatae date default sysdate,
constraint emppk primary key(empno)
);





-- DEPT 테이블 생성
CREATE TABLE DEPT
(
deptno varchar(2) primary key,
deptname varchar2(20)
);

-- 'ALTER'로 EMP테이블에 외래키 설정
-- "CONSTRAINT 제약조건명 FOREIGN KEY(외래키 칼럼명) REFERENCES 참조테이블(참조테이블_PK)"
-- 'REFERENCES'에서 'S'붙는 것 명심
ALTER TABLE EMP ADD CONSTRAINTS deptfk foreign key (deptno) references DEPT (deptno);





-- FOREGIN KEY CONSTRAINT에서 'ON DELETE CASCADE' 설정하기
-- 'ON DELETE CASCADE'옵션은 자신이 참조하고 있는 테이블의 데이터가 삭제되면, 테이블 내 해당 데이터와 관련있는 인스턴스도 삭제되는 옵션이다.
-- 해당 옵션을 사용하면, '참조 무결성'을 준수할 수 있다. 참조 무결성이란, 마스터 테이블에는 해당 부서번호가 없는데, 슬레이브 테이블에는 해당 부서번호가 있는 경우를 참조 무결성 위배로 볼 수 있다.
CREATE TABLE DEPT
(
 deptno VARCHAR2(4),
 deptname VARCHAR2(20),
 CONSTRAINT dptnopk PRIMARY KEY(deptno)
);

INSERT INTO DEPT VALUES('1000', '인사팀');
INSERT INTO DEPT VALUES('1001', '총무팀');

CREATE TABLE EMP
(
    empno number(10),
    ename varchar2(20),
    sal number(10,2) default 0,
    deptno varchar2(4) not null,
    createdate date default sysdate,
    CONSTRAINT empnopk primary key(empno),
    CONSTRAINT deptfk FOREIGN key(deptno) REFERENCES DEPT(deptno) ON DELETE CASCADE
);

INSERT INTO EMP VALUES(100, '임베스트', 1000, '1000', sysdate);
INSERT INTO EMP VALUES(101, '을지문덕', 2000, '1001', sysdate);
SELECT * FROM EMP;

DELETE FROM DEPT WHERE DEPTNO = '1000';
SELECT * FROM EMP;





-- 'ALTER TABLE 테이블명' DDL을 통해 테이블을 변경할 수 있으며, 테이블명 변경, 칼럼 추가, 칼럼 변경, 칼럼 삭제 등을 할 수 있다.

-- 'ALTER TABLE ~ RENAME TO ~'을 통해 테이블명을 변경할 수 있다.
ALTER TABLE EMP RENAME TO NEW_EMP;

-- 'ALTER TABLE 테이블명 ADD()'을 통해 칼럼을 추가할 수 있다.
ALTER TABLE NEW_EMP ADD(age NUMBER(2) default 1);

-- 'ALTER TABLE 테이블명 MODIFY'을 통해 칼럼을 변경할 수 있다.
ALTER TABLE NEW_EMP MODIFY(ENAME VARCHAR2(40) NOT NULL);

-- 'ALTER TABLE 테이블명 DROP COLUMN 컬럼명'을 통해 칼럼을 삭제할 수 있다.
-- 'DROP'이 아니라 'DROP COLUMN'인 것을 명심해야 한다.
-- 'DROP COLUMN' 뒤에 괄호 없이 바로 삭제할 칼럼이 적힌다는 것을 명심해야 한다.
ALTER TABLE NEW_EMP DROP COLUMN AGE;

-- 'ALTER TABLE 테이블명 REANME COLUMN 기존의 칼럼명 TO 변경될 이름의 칼럼명'을 통해 칼럼명을 변경할 수 있다.
ALTER TABLE NEW_EMP RENAME COLUMN ENAME TO NEW_ENAME;






-- 'DROP TABLE' DDL을 통해서 테이블을 삭제할 수 있다.
CREATE TABLE TEST
(
    TEST_1 VARCHAR2(9),
    TEST_2 NUMBER(4)
);

INSERT INTO TEST VALUES('TEST', 4);

SELECT * FROM TEST;

DROP TABLE TEST;

-- 'DROP TABLE ~ CASCADE CONSTRAINT'를 통해서 해당 테이블을 참조한 슬레이브 테이블과 관련된 제약사항도 삭제할 수 있다.





-- 'CREATE VIEW 뷰명 AS SELECT ~ ' DDL을 통해서 View를 생성할 수 있다.
-- View란 테이블로부터 유도된 가상의 테이블이다.
-- 실제 데이터를 가지고 있지 않고, 특정 테이블을 참조해서 원하는 컬럼만 조회할 수 있게 한다.
-- DBA가 View를 통해 특정 칼럼만 가진 가상의 테이블을 생성시키면, 사용자는 실제 테이블에 대해서 자세히 알 수 없다. 
-- 결국 실제 존재하는 테이블에 대한 보안성이 향상되고, 기존 테이블의 데이터 관리가 간단해진다.
-- 하나의 테이블에 대한 여러 개의 뷰를 생성할 수 있다.
-- 참조한 테이블이 변경되면 뷰도 변경된다.
-- 한번 생성된 뷰는 변경할 수 없고, 변경을 원하면 삭제 후 재생성해야 한다. 즉, ALTER문을 사용해서 뷰를 변경할 수 없다.

-- 장점 : 보안 기능, 데이터 관리 용이, 사용자의 SELECT문이 간단해짐
-- 단점 : 독자적인 인덱스를 만들 수 없음, 삽입 수정 삭제 연산이 제약됨, 데이터 구조를 변경할 수 없음
CREATE VIEW T_EMP AS SELECT EMPNO, NEW_ENAME FROM NEW_EMP; 

SELECT * FROM T_EMP





-- 'INSERT INTO' DML을 통해 특정 테이블에 인스턴스를 추가할 수 있다. 
-- 'VALUES'의 'S'붙는 것 명심
-- 데이터를 입력할 때 문자열을 입력하는 경우에는 작은따옴표를 사용해야 한다.
-- INSERT문을 실행했다고 데이터 파일에 저장되는 것은 아니다. 최종적으로 데이터를 저장하려면 TCL문인 'Commit'을 실행해야 한다.
-- 만약 'Auto Commi't으로 설정된 경우에는 Commit을 실행하지 않아도 바로 데이터 파일에 저장된다.
INSERT INTO EMP VALUES(100, '임베스트', 1000, '1000', sysdate);

-- 대량의 데이터를 INSERT하면, 오랜 시간이 소요될 수 있다.
-- 데이터베이스에 데이터를 입력할 때마다 로그파일에 그 정보를 기록하는데, 이것이 INSERT 성능을 저하시킨다.
-- 'ALTER TABLE 테이블명 NOLOGGING'을 통해, 로그파일에 대한 기록을 최소화시킬 수 있다.
ALTER TABLE NEW_EMP NOLOGGING;






-- 'UPDATE 테이블명 SET ~ WHERE ~'DML을 통해, 기존의 테이블에 이미 입력된 데이터 값을 수정할 수 있다.
-- 데이터를 수정할 때 조건절에서 검색되는 행 수만큼 수정이 된다.
-- 만약, WHERE 조건문을 입력하지 않으면 모든 데이터가 수정되므로 유의해야 한다.
INSERT INTO new_emp VALUES(102, '가나다라', 3000, '1001', sysdate);
UPDATE new_emp SET SAL = 4000 WHERE SAL = 3000;
SELECT * FROM NEW_EMP;






-- 'DELETE FROM 테이블명 WHERE ~'DML을 통해, 조건에 맞는 인스턴스를 삭제할 수 있다.
-- 만약, WHERE절을 입력하지 않으면, 테이블 내 모든 인스턴스가 삭제된다.
-- DELETE를 통해 인스턴스를 삭제한다고 해서, 테이블의 용량이 초기화되지 않는다.
INSERT INTO new_emp VALUES(102, '가나다라', 3000, '1001', sysdate);
UPDATE new_emp SET SAL = 4000 WHERE SAL = 3000;
SELECT * FROM NEW_EMP;

DELETE FROM new_emp WHERE new_ename = '가나다라';
SELECT * FROM NEW_EMP;






-- 'SELECT 컬럼명 || 문자열 FROM 테이블명'DML을 통해, 특정 컬럼에 들어있는 모든 데이터 값에다 지정한 문자열을 결합한 결과물을 조회할 수 있다.
SELECT EMPNO, NEW_ENAME || '님' FROM NEW_EMP;






-- 'ORDER BY 컬럼명'DML을 통해, 데이터를 오름차순 또는 내림차순으로 출력할 수 있다.
-- 'ORDER BY 컬럼명 DESC'를 통해, 지정한 컬럼에 대한 내림차순으로 출력할 수 있다.
-- 해당 DML은 데이터베이스 메모리를 많이 사용하게 된다. 그러므로 대량의 데이터를 정렬하게 되면, 정렬로 인한 성능 저하가 발생한다.
CREATE TABLE EMP
(
EMPNO NUMBER(10),
ENAME VARCHAR2(20),
SAL NUMBER(10),

CONSTRAINT EMPNO_PK PRIMARY KEY(EMPNO)
);

INSERT INTO EMP VALUES(1000, '임베스트', 20000);
INSERT INTO EMP VALUES(1001, '조조', 20000);
INSERT INTO EMP VALUES(1002, '관우', 20000);
INSERT INTO EMP VALUES(999, '가나다라', 10000);

SELECT * FROM EMP ORDER BY EMPNO DESC;






-- 'ORDER BY' 정렬 성능 저하는 Oracle hint를 사용하여 해결할 수 있다.
-- 힌트란 SQL 튜닝의 핵심 부분으로 일종의 지시 구문이다.
-- 즉, 오라클 옵티마이저(Optimizer)에게 SQL문 실행을 위한 데이터를 스캐닝하는 경로, 조인하는 방법 등을 알려주기 위해, SQL사용자가 SQL 구문에 작성하는 것을 뜻한다. 
-- 오라클이 항상 최적의 실행 경로를 만들어 내기는 불가능하기 때문에, 직접 최적의 실행 경로를 작성해 주는 것이다.
-- 기본적으로 쿼리의 서두에 힌트를 명시해야 한다.
-- 'SELECT /*+ INDEX_DESC(테이블명 인덱스명) */ 컬럼명'을 입력하면, INDEX를 이용한 정렬을 실시한다.
SELECT /*+ INDEX_DESC(EMP EMPNO_PK) */ * FROM EMP;






-- 실행계획 출력 쿼리
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL,NULL,'ALLSTATS LAST'));





-- DISTINCT 사용법
-- SELECT 내 'DISTINCT'를 컬럼명 앞에 적어주면, 중복되지 않은 데이터를 보여준다.
SELECT DISTINCT SAL FROM EMP;






-- ALIAS 사용법
-- 칼럼에 대한 별명 설정은 'AS ~'로 하면되고, 테이블에 대한 별명 설정은 원래 테이블명 옆에 띄어쓰고 바로 기재해주면 된다.
SELECT EMPNO, ENAME, SAL AS 연봉 FROM EMP E WHERE E.SAL = 20000;






-- WHERE문이 사용하는 연산자

-- '!=', '^=', '<>'는 전부 부등호를 의미하는 연산자이다.
-- 연산식앞에 NOT을 붙일 수 있다. 그래서 'WHERE SAL != 10000'과 'WHERE NOT SAL = 10000'은 같은 의미이다. 
SELECT * FROM EMP E WHERE e.sal != 10000;
SELECT * FROM EMP E WHERE NOT E.SAL = 10000;

-- '컬럼명 BETWEEN A AND B' 해당 컬럼 내 A와 B 사이에 존재하는 데이터를 조회한다.
SELECT * FROM EMP E WHERE e.sal BETWEEN 20000 AND 30000;

-- 'IN(list)'는 'OR'을 의미하며, list 값 중 하나만 일치해도 조회된다.
INSERT INTO EMP VALUES(1003, 'HIHI', 15000);
SELECT * FROM EMP E WHERE E.SAL IN (10000, 15000);






-- 와일드카드(%, _)를 사용하는 'LIKE'문
-- 'WHERE'절에서 와일드카드를 사용하기 위해선 '컬럼명 LIKE ~'으로 시작해야한다.
-- '%'는 어떤 문자를 포함한 도느 것을 조회한다.
SELECT * FROM EMP E WHERE E.ENAME LIKE '임%';

-- '_'는 한 개인 단일 문자를 의미한다. 
SELECT * FROM EMP E WHERE E.ENAME LIKE '임베스_'; 





-- 'NULL'은 모르는 값을 의미한다.
-- 'NULL'은 값의 부재를 의미한다.
-- 'NULL'과 어떤 값을 비교할 때, '알 수 없음'이 반환된다.
-- 'NULL'과 숫자 혹은 날짜를 더하면 NULL이 된다.
SELECT 1+NULL FROM DUAL;

-- NULL값을 조회할 경우는 'IS NULL'을 사용하고 NULL값이 아닌 것을 조회할 경우는 'IS NOT NULL'을 사용한다.
INSERT INTO EMP(EMPNO, ename) VALUES(1004, 'BYE');
SELECT * FROM EMP E WHERE SAL IS NULL;

-- NVL(컬럼명, 지정값) : 컬럼 내 NULL값을 '지정값'으로 변형하는 함수
SELECT EMPNO, ENAME, NVL(SAL, 0) AS FIEXED FROM EMP;

-- NVL2(컬럼명, 지정값1, 지정값2) : 컬럼 내 NULL값이 아닌 것을 '지정값1'로 변형하고 NULL값인 것을 '지정값2'로 변형하는 함수
SELECT EMPNO, ENAME, NVL2(SAL, 1, 0) AS FIEXED FROM EMP;

-- NULLIF(컬럼명1, 컬럼명2) : 두 컬럼 내 데이터 값이 같으면 NULL값을, 같지 않으면 '컬럼명1'에 해당하는 값을 반환하는 함수

-- COALESCE(컬럼명1, 컬럼명2, 컬럼명3, ...) : NULL이 아닌 최초의 인자를 반환하는 함수
-- 즉, '컬럼명1'에 해당하는 값이 NULL이 아니면 '컬럼명1'에 해당하는 값을, 그렇지 않으면 그 뒤의 값의 NULL 여부를 판단하여 값을 반환한다.





-- 'GROUP BY'절은 데이터들을 원하는 그룹으로 나눌 수 있다.
-- 나누고자 하는 그룹 컬럼명을 SELECT절과 GROUP BY절 뒤에 추가하면 된다.
SELECT DEPTNO, SUM(SAL) AS SALLARY_SUM FROM EMP GROUP BY DEPTNO ;

-- 'HAVING'구를 통해, 'GROUP BY'절에 의한 생성된 결과 값 중 원하는 조건에 부합하는 값만 볼 수 있다.
-- 즉, 'HAVING'구가 반환되는 최종 결과물에 대한 마지막 조건문 역할을 수행한다.
SELECT DEPTNO, SUM(SAL) AS SALLARY_SUM FROM EMP GROUP BY DEPTNO HAVING SUM(SAL) < 30000;
