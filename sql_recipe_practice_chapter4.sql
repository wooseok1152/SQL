/* 날짜별 매출과 평균 구매액을 집계하는 방법 */
SELECT * FROM PURCHASE_LOG;

SELECT DT, COUNT(*) AS PURCHASE_COUNT, SUM(PURCHASE_AMOUNT) AS TOTAL_AMOUNT, ROUND(AVG(PURCHASE_AMOUNT), 2) AS AVG_AMOUNT
FROM PURCHASE_LOG
GROUP BY DT
ORDER BY DT
;

/* 날짜별 매출과 7일 이동평균을 집계하는 방법 */
SELECT DT, SUM(PURCHASE_AMOUNT) AS TOTAL_AMOUNT, 
    CASE 
        WHEN COUNT(*) OVER(ORDER BY DT ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) = 7 
        THEN AVG(SUM(PURCHASE_AMOUNT)) OVER(ORDER BY DT ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) END AS SEVEN_DAU_MOVING_AVG 
    
FROM PURCHASE_LOG 
GROUP BY DT 
ORDER BY DT; 

/* 월 매출과 월 매출 누계 구하는 방법 */
SELECT * FROM PURCHASE_LOG;

WITH MONTH_TOTAL_AMOUNT 
AS(SELECT DT, SUBSTR(DT, 1, 7) AS YEAR_MONTH ,SUM(PURCHASE_AMOUNT) AS MONTH_TOTAL FROM PURCHASE_LOG GROUP BY DT ORDER BY DT)
SELECT DT, YEAR_MONTH, MONTH_TOTAL, SUM(MONTH_TOTAL) OVER(PARTITION BY YEAR_MONTH ORDER BY YEAR_MONTH ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS AGG_AMOUNT FROM MONTH_TOTAL_AMOUNT;

/* 날짜별 매출을 조회를 좀 더 보기 좋게 나타내는 방법(즉, 년, 월, 일 컬럼을 따로 제작하는 방법)(해당 SQL의 결과를 'daily_purchase'라 명명함) */
SELECT * FROM PURCHASE_LOG;

WITH PURCHASE_AMOUNT_BY_MONTH AS
(
SELECT DT, SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT 
FROM PURCHASE_LOG 
GROUP BY DT 
ORDER BY DT
) 
SELECT DT, SUBSTR(DT, 1, 4) AS YEAR, SUBSTR(DT, 6, 2) AS MONTH, SUBSTR(DT, 9, 2) AS DATE_, PURCHASE_AMOUNT 
FROM PURCHASE_AMOUNT_BY_MONTH;

/* daily_purchase(위 sql의 결과)로부터 월별 매출 누계를 구하는 방법*/
WITH PURCHASE_AMOUNT_BY_MONTH AS
(
SELECT DT, SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT 
FROM PURCHASE_LOG 
GROUP BY DT 
ORDER BY DT
),
DAILY_PURCHASE AS 
(
SELECT DT, SUBSTR(DT, 1, 4) AS YEAR, SUBSTR(DT, 6, 2) AS MONTH, SUBSTR(DT, 9, 2) AS DATE_, PURCHASE_AMOUNT 
FROM PURCHASE_AMOUNT_BY_MONTH
),
MONTH_PURCHASE AS
(
SELECT DT, YEAR||'-'||MONTH AS YEAR_MONTH, PURCHASE_AMOUNT FROM DAILY_PURCHASE
) SELECT DT, YEAR_MONTH, PURCHASE_AMOUNT, SUM(PURCHASE_AMOUNT) OVER(PARTITION BY YEAR_MONTH ORDER BY YEAR_MONTH ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS AGG_AMNOUNT_BY_MONTH FROM MONTH_PURCHASE;

/* SUM(CASE ~)예시 */
CREATE TABLE SUM_CASE_TEST
(
MAIN_NAME VARCHAR2(20),
SUB_NAME VARCHAR2(20),
AMOUNT INTEGER
);

INSERT INTO SUM_CASE_TEST VALUES('A', 'a', 1);
INSERT INTO SUM_CASE_TEST VALUES('A', 'a', 10);
INSERT INTO SUM_CASE_TEST VALUES('A', 'b', 2);
INSERT INTO SUM_CASE_TEST VALUES('B', 'a', 3);
INSERT INTO SUM_CASE_TEST VALUES('B', 'b', 4);

SELECT * FROM SUM_CASE_TEST;

SELECT MAIN_NAME, SUM(CASE WHEN SUB_NAME = 'a' THEN AMOUNT END) AS SUM_CASE FROM SUM_CASE_TEST GROUP BY MAIN_NAME ORDER BY MAIN_NAME;

/* 월별 매출 작대비 구하기(SUM(CASE ~)활용법) */
WITH PURCHASE_AMOUNT_BY_MONTH AS
(
SELECT DT, SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT 
FROM PURCHASE_LOG_14_15 
GROUP BY DT 
ORDER BY DT
),
DAILY_PURCHASE AS 
(
SELECT DT, SUBSTR(DT, 1, 4) AS YEAR, SUBSTR(DT, 6, 2) AS MONTH, SUBSTR(DT, 9, 2) AS DATE_, PURCHASE_AMOUNT 
FROM PURCHASE_AMOUNT_BY_MONTH
),
MST_MONTH AS
(
SELECT DISTINCT SUBSTR(DT, 6, 2) AS MONTH 
FROM PURCHASE_AMOUNT_BY_MONTH ORDER BY MONTH
),
AMOUNT_14_15_BY_MONTH AS
(
SELECT MONTH, SUM(CASE WHEN YEAR = '2014' THEN PURCHASE_AMOUNT END) AS AMOUNT_2014, SUM(CASE WHEN YEAR = '2015' THEN PURCHASE_AMOUNT END) AS AMOUNT_2015 
FROM DAILY_PURCHASE 
GROUP BY MONTH 
ORDER BY MONTH
) SELECT MONTH, AMOUNT_2014, AMOUNT_2015, ROUND((AMOUNT_2015/AMOUNT_2014) * 100) AS RATE FROM AMOUNT_14_15_BY_MONTH;

/* 2015년 매출의 Z 차트를 작성하기 위한 테이블 조회 방법 */
WITH PURCHASE_AMOUNT_BY_MONTH AS
(
SELECT DT, SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT 
FROM PURCHASE_LOG_14_15 
GROUP BY DT 
ORDER BY DT
),
DAILY_PURCHASE AS 
(
SELECT DT, SUBSTR(DT, 1, 4) AS YEAR, SUBSTR(DT, 6, 2) AS MONTH, SUBSTR(DT, 9, 2) AS DATE_, PURCHASE_AMOUNT 
FROM PURCHASE_AMOUNT_BY_MONTH
),
MONTHLY_AMOUNT AS
(
SELECT YEAR, MONTH, SUM(PURCHASE_AMOUNT) AS YEAR_MONTH_AMOUNT FROM DAILY_PURCHASE GROUP BY YEAR, MONTH ORDER BY YEAR, MONTH
),
calc_index AS
(
SELECT YEAR, MONTH, YEAR_MONTH_AMOUNT, SUM(CASE WHEN YEAR = '2015' THEN YEAR_MONTH_AMOUNT END) OVER(ORDER BY YEAR, MONTH ROWS UNBOUNDED PRECEDING) AS AGG_AMOUNT FROM MONTHLY_AMOUNT
),
CALC_INDEX_WITH_ONE_YEAR_AGG_AMOUNT AS
(
SELECT YEAR, MONTH, YEAR_MONTH_AMOUNT, AGG_AMOUNT, SUM(YEAR_MONTH_AMOUNT) OVER(ORDER BY YEAR, MONTH ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS YEAR_AGG_AMOUNT FROM CALC_INDEX
) SELECT YEAR||'-'||MONTH AS YEAR_MONTH, YEAR_MONTH_AMOUNT, AGG_AMOUNT, YEAR_AGG_AMOUNT FROM CALC_INDEX_WITH_ONE_YEAR_AGG_AMOUNT WHERE YEAR = '2015';

/* 카테고리별 매출과 소계 계산하기 */
WITH MEN_FASHION_AND_LAD_FASHION_AGG_SUM_TABLE AS
(
SELECT CATEGORY, SUB_CATEGORY, SUM(PRICE) AS AGG_SUM_PRICE FROM PURCHASE_DETAIL_LOG WHERE CATEGORY = 'mens_fashion' or CATEGORY = 'ladys_fashion' GROUP BY ROLLUP(CATEGORY, SUB_CATEGORY)
) SELECT CASE WHEN CATEGORY IS NULL THEN 'ALL' ELSE CATEGORY END AS CATEGORY, CASE WHEN SUB_CATEGORY IS NULL THEN 'ALL' ELSE SUB_CATEGORY END AS SUB_CATEGORY, AGG_SUM_PRICE FROM MEN_FASHION_AND_LAD_FASHION_AGG_SUM_TABLE;

/* ABC 분석으로 잘 팔리는 상품 판별하기 */
-- A 등급 : 상위 0~70%, B 등급 : 상위 70~90%, C 등급 : 상위 90~100%
WITH WHOLE_AGG_SUM_TABLE AS
(
SELECT CATEGORY, SUM(PRICE) AS AGG_SUM_BY_CATEGORY FROM PURCHASE_DETAIL_LOG GROUP BY ROLLUP(CATEGORY)
), WHOLE_AGG_SUM_TABLE_WITH_SUM_OF_AGG_SUM AS
(
SELECT CATEGORY, AGG_SUM_BY_CATEGORY, SUM(AGG_SUM_BY_CATEGORY) OVER(ORDER BY AGG_SUM_BY_CATEGORY ROWS BETWEEN UNBOUNDED PRECEDING AND 8 FOLLOWING) AS SUM_OF_AGG_SUM FROM WHOLE_AGG_SUM_TABLE
), WITH_AGG_SUM_BY_CATEGORY_DESC AS
(
SELECT * FROM WHOLE_AGG_SUM_TABLE_WITH_SUM_OF_AGG_SUM WHERE CATEGORY IS NOT NULL ORDER BY AGG_SUM_BY_CATEGORY DESC
), WITH_RATIO AS
(
SELECT CATEGORY, AGG_SUM_BY_CATEGORY, ((AGG_SUM_BY_CATEGORY/SUM_OF_AGG_SUM)*2)*100 AS RATIO FROM WITH_AGG_SUM_BY_CATEGORY_DESC
), WITH_CUMU_RATIO AS
(
SELECT CATEGORY, AGG_SUM_BY_CATEGORY, RATIO, SUM(RATIO) OVER(ORDER BY RATIO DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CUMU_RATIO FROM WITH_RATIO
), WITH_ABC_RANK AS
(
SELECT CATEGORY, AGG_SUM_BY_CATEGORY, RATIO, CUMU_RATIO, CASE WHEN CUMU_RATIO <= 70 THEN 'A' WHEN CUMU_RATIO <= 90 THEN 'B' ELSE 'C' END AS ABC_RANK FROM WITH_CUMU_RATIO
) SELECT * FROM WITH_ABC_RANK;

SELECT * FROM WITH_CUMU_RATIO;

, WITH_CUMU_RATIO AS
 (
 SELECT CATEGORY, AGG_SUM_BY_CATEGORY, RATIO, SUM(RATIO) OVER(ORDER BY RATIO DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CUMU_RATIO FROM WITH_RATIO
 ), WITH_CUMU_RATIO_FIXED AS
 (
 SELECT CATEGORY, AGG_SUM_BY_CATEGORY, RATIO, CASE WHEN CUMU_RATIO > 100 THEN NULL ELSE CUMU_RATIO END AS CUMU_RATIO FROM WITH_CUMU_RATIO
 ) SELECT * FROM WITH_CUMU_RATIO_FIXED;
 
 /* FIRST_VALUE 함수(GROUP 함수 중 하나) 활용법 */
 CREATE TABLE FIRST_VALUE_FUNC_TEST
 (
 GROUP_NAME VARCHAR2(255),
 PRICE INTEGER
 );
 
 INSERT INTO FIRST_VALUE_FUNC_TEST VALUES('A', 1);
 INSERT INTO FIRST_VALUE_FUNC_TEST VALUES('A', 4);
 INSERT INTO FIRST_VALUE_FUNC_TEST VALUES('A', 5);
 INSERT INTO FIRST_VALUE_FUNC_TEST VALUES('B', 2);
 INSERT INTO FIRST_VALUE_FUNC_TEST VALUES('B', 7);
 
 SELECT FIRST_VALUE(PRICE) OVER(PARTITION BY GROUP_NAME ORDER BY PRICE) AS FIRST_VALUE_FUNC_RESULT FROM FIRST_VALUE_FUNC_TEST;
 
 /* 팬 차트로 상품의 매출 증가율 확인하기 */
 WITH DAILY_PURCHASE AS
 (
 SELECT SUBSTR(DT, 1, 4) AS YEAR, SUBSTR(DT, 6, 2) AS MONTH, SUBSTR(DT, 9, 2) AS DATE_, CATEGORY, SUM(PRICE) AS AGG_SUM_BY_CATEGORY FROM purchase_detail_log GROUP BY DT, CATEGORY
 ), MONTHLY_CATEGORY_PURCHASE AS
 (
 SELECT YEAR || '-' || MONTH AS YEAR_MONTH, CATEGORY, AGG_SUM_BY_CATEGORY FROM DAILY_PURCHASE 
 ), WITH_STANDARD_OF_EACH_CATEGORY AS
 (
 SELECT YEAR_MONTH, CATEGORY, AGG_SUM_BY_CATEGORY, FIRST_VALUE(AGG_SUM_BY_CATEGORY) OVER(PARTITION BY CATEGORY ORDER BY YEAR_MONTH) AS STANDARD_OF_EACH_CATEGORY  FROM MONTHLY_CATEGORY_PURCHASE
 ) SELECT YEAR_MONTH, CATEGORY, AGG_SUM_BY_CATEGORY, STANDARD_OF_EACH_CATEGORY, 100 * (agg_sum_by_category/STANDARD_OF_EACH_CATEGORY) AS RATE FROM WITH_STANDARD_OF_EACH_CATEGORY;
 
/* 최댓값, 최솟값, 범위를 구하는 방법 */
-- 주어진 데이터들의 최댓값, 최솟값, 범위를 구하는 방법
WITH STATS AS 
(
SELECT MAX(PRICE) AS MAX_PRICE, MIN(PRICE) AS MIN_PRICE, MAX(PRICE) - MIN(PRICE) AS RANGE_PRICE, 10 AS BUCKET_NUM FROM PURCHASE_DETAIL_LOG
) SELECT * FROM STATS;

-- 각 데이터가 어느 계급에 포함되는지에 대해 구하는 방법
WITH STATS AS 
(
SELECT MAX(PRICE) AS MAX_PRICE, MIN(PRICE) AS MIN_PRICE, MAX(PRICE) - MIN(PRICE) AS RANGE_PRICE, 10 AS BUCKET_NUM FROM PURCHASE_DETAIL_LOG
), PURCHASE_LOG_WITH_BUCKET AS
(
SELECT PRICE, MIN_PRICE, PRICE - MIN_PRICE AS NORMAL_VALUE, 1.0 * RANGE_PRICE / BUCKET_NUM AS BUCKET_RANGE, FLOOR(1.0 * (PRICE - MIN_PRICE) / (1.0 * RANGE_PRICE / BUCKET_NUM)) + 1 AS BUCKET
FROM PURCHASE_DETAIL_LOG, STATS
) SELECT * FROM PURCHASE_LOG_WITH_BUCKET ORDER BY PRICE;







